// import { useEffect, useState } from "react";
import Head from "next/head";
import MeetupList from "../components/meetups/MeetupList";

import { MongoClient } from "mongodb";

// const DUMMY_MEETUPS = [
//   {
//     id: "m1",
//     title: "첫번째 밋업 입니다.",
//     image:
//       "https://cdn.pixabay.com/photo/2016/11/21/17/44/arches-national-park-1846759_1280.jpg",
//     address: "미국 로스엔젤레스",
//     description: "첫번째 밋업 장소입니다.1111",
//   },
//   {
//     id: "m2",
//     title: "두번째 밋업 입니다.",
//     image:
//       "https://cdn.pixabay.com/photo/2018/11/29/21/19/hamburg-3846525_1280.jpg",
//     address: "이탈리아 피렌체",
//     description: "두번째 밋업 장소입니다.",
//   },
// ];

const HomePage = (props) => {
  // const [loadedMeetups, setLoadedMeetups] = useState([]);

  // useEffect(() => {
  //   // http
  //   setLoadedMeetups(DUMMY_MEETUPS);
  // }, []);

  return (
    <>
      <Head>
        <title>수암이의 NextJs 모뎀 프로젝트</title>
        <meta
          name="description"
          content="밋업 커뮤니티를 위한 훌륭한 웹 서비스 입니다."
        ></meta>
      </Head>
      <MeetupList meetups={props.meetups} />
    </>
  );
};

// 정적 사이트(SSG) 데이터 패칭
export async function getStaticProps() {
  // 더미 meetups데이터 대신 몽고db에 있는 데이터 패칭해오기
  // 이 함수 안 로직은 빌드프로세스중 서버에서 실행되기에 클라이언트단에선 확인할 수 없다. 그래서 fetch가 중복체크될 여지가 있다. 그러므로 모든 해당 api 앤드포인트의 데이터를 다 불러오려면 getStaticProps 내부나 여기서 실행하는 헬퍼 함수에 코드를 직접 작성해야한다.
  // 불필요한 요청을 추가로 작성하지 않으려면 여기서 db에 접근하여 실행하게 하고 이렇게 되면 nextJs가 이를 감지해 발드 시, 클라이언트 측 번들에 포함시키지 않기 때문에 번들 크기 뿐 아니라 보안에도 유용해진다.

  // 바로 몽고db 접근
  const client = await MongoClient.connect(
    "mongodb+srv://SuamKang:Suamy1452@cluster0.p9kse3c.mongodb.net/meetups?retryWrites=true&w=majority"
  );
  const db = client.db();
  const meetupsCollection = db.collection("meetups");

  // find메소드로 컬렉션에서 모든 문서 찾기
  const meetups = await meetupsCollection.find().toArray(); // 해당 데이터 문서를 배열로 받는 방법

  client.close();

  // 에러발생!!
  // ** 자동생성된 id 에러 문구사진
  // 데이터를 받을려할때 해당 데이터에 부여된 id가 문자열이 아닌 객체형태의 id가 존재하는것으로 확인된다. 즉 직렬화될수없는 형태임에 에러가 난것!! 이 객체형태의 id를 사용가능한 문자열로 변환시키게 해야한다.
  // 이를 해결하기 위해선 db에서 가져온 meetups데이터들을 직렬화 가능하도록 변형시켜(맵핑) props로 저장 시켜주면 될것같다.

  return {
    props: {
      meetups: meetups.map((meetup) => ({
        id: meetup._id.toString(), // id 직렬화
        title: meetup.title,
        address: meetup.address,
        image: meetup.image,
      })),
    },
    revalidate: 1,
  };
}

// // 서버 사이드 렌더링(SSR) 데이터 패칭
// export async function getServerSideProps(context) {
//   const request = context.req;
//   // const response = context.res;

//   // fetch data from an API

//   return {
//     props: {
//       meetups: DUMMY_MEETUPS,
//     },
//   };
// }

export default HomePage;

// Page Pre-Rendering

// remind -> useEffect는 컴포넌트 함수가 렌더링 되고 난 후에 이펙트 함수가 실행되는 방식이다. -> 즉 처음에는 응답받아온 loadedMeetups가 빈배열로 들어있다는 것! -> 그리고 이펙트함수(http)실행후 상태 업데이트 된 후에 다시 실행되면서 렌더링 가능하게 됨
// 하지만 우리가 nextJs를 접목했던 이유는 이 백엔드와 통신시 로딩상태가 발생할 수 밖에 없는데 이를 좋은 ux를 위해서 였다.
// 이처럼 2번의 렌더링 사이클 때문에 SEO에도 문제가 생길 수 있는 부분이 존재한다.

// 문제가 무엇이냐?
// 페이지에 최초로 접속시에 담겨있는 html컨텐츠에는 실제 백엔드로 부터 받아온 데이터가 안담겨있다.(페이지 소스에서 확인 가능)
// 즉, 서버에서 가져온 html페이지에는 컨텐츠가 없다. 이유는 이것들이 두번째 컴포넌트 실행(http 비동기 요청후)사이클에서만 렌더링 되기 때문이다.
// 하지만 nextJs가 자동으로 생성하는 사전렌더링된 페이지(첫번쩨 렌더링 사이클로부터 가져온 페이지)는 이 두번째 사이클을 기다리지 않는다. 언제나 첫번째 렌더링 사이클의 결과를 가져와서 사전렌더링한 html코드를 반환해준다.
// 그래서 이러한 문제의 해결책을 nextJs가 가지고 있으며, 내장된 주요기능으로 이 문제를 해결할 수 있다. 데이터가 있는 페이지를 사전 렌더링해야 하지만 그 데이터는 클라이언트가 기다려야한다. 그리고 다 받아오게 됐을때, nextJs에 알려야 하는것이다.

// 정적 페이지에 대한 데이터 가져오기

// nextJs에서 사전 렌더링된 페이지는 컴포넌트가 첫번째 렌더링 사이클을 마친 이후의 스냅샷을 컨텐츠로 갖고 있으며 이미 데이터는 손실된 상태로 있게 된다.
// 만약 어떤 라우터가 있다면 요청은 라우터에 전해지고 페이지로 이동하게 된다. 그리고나서 사전 렌더링한 페이지를 반환하지만 데이터는 손실된 상태이며 이론적으론 SEO에 좋을지 몰라도 항상 좋은부분은 아니다.
// html페이지를 받은 후에 react가 이를 체크하고 페이지에 hydrate작업을 수행한다.
// 즉, 리엑트가 SPA로 만들고 제어하게 되는 작업인것이다.-> useEffect함수를 실행하고 데이터를 받아와서 브라우저에서 업데이트 하게되고 -> 이 경우엔 브라우저에서 페이지를 받은 후 하는 작업이라 필요한 모든 데이터가 있는 완전한 대화형 페이지나 앱을 갖게 되는것이다.

// 하지만 이런 작업형태가 아닌, 초기에 반환된 html코드에 이미 데이터가 포함되도록 페이지를 사전 렌더링 하려면 이 내장된 사전 렌더링 프로세스를 조정해야하고 그에 맞는 설정도 필요하다.
// 이를 위한 nextJs에서 제공하는 2가지 렌더링 제어 방법이 있다.

// 1. 정적 사이트 생성(SSG)
// 2. 서버 사이드 렌더링(SSR)

// 이 둘은 서로 다른 시점에서 코드가 실행된다.

// 1. 정적 생성
// 정적 생성에서 페이지 컴포넌트가 사전 렌더링 되는 시점은 앱을 빌드하거나 next 프로젝트를 빌드하는 시점 즉, 프로덕션용으로 빌드하는 시점이다. (매우 중요!!)

// 정적 생성에서는 기본적으로 요청이 서버에 도달했을 때 서버에서 즉각적으로 페이지를 사전 렌더링 하지 않는다. 대신 개발자가 직접 프로덕션용 사이트를 빌드(npm run build)할때 사전 렌더링을 한다.
// 쉽게말해, 사이트가 배포되고 나면 사전 렌더링한 페이지는 변경되지 않는다는 뜻이다.
// 데이터를 업데이트했는데 사전 렌더링한 페이지를 만약 변경해야 한다면 해당 빌드 프로세스를 다시 시작하고 다시 배포해야한다. -> 페이지안 컨텐츠가 매번 바뀌는게 아니라면 실제로 이 작업은 나쁘다고만 볼 수 없고 이에대한 대안도 존재한다.

// 우선 정적생성을 통해 페이지를 생성했지만, 데이터를 기다려야 한다면(데이터 패칭), pages 컴포넌트 파일 안에서 특수함수를 export해주어야 한다. (매우 중요!!) 이는 오직 pages 컴포넌트 파일에서만 작동한다.

//  바로 "getStaticProps"라는 함수이다.(정해진 이름임)
// 이 함수가 실행되는 시점은 컴포넌트 함수를 호출하기 전이고, 반환된 jsx코드들을 html컨텐츠로 사용하며, 실제로 해당 페이지에서 사용할 props를 준비해준다.

// 사전 렌더링 프로세스(빌드과정 안에서 동작) :
// 해당 페이지 접속 -> 해당 페이지에 export하는 'getStaticProps'함수 호출 -> jsx코드들 html컨텐츠로 사용 -> getStaticProps가 반환하는 promise의 상태에 따라 기다림 -> 패칭이 완료되면 컴포넌트 함수를 호출해서 이 props를 사용함 -> 컴포넌트함수가 실행되기 이전에 이미 데이터를 읽어왔기에 데이터와 함께 렌더링 가능!

// "getStaticProps" -> SSG

// 필요한 데이터가 담겨있다. 비동기적으로 설정도 가능하다. -> promise를 반환해준다.

// getStaticProps 함수 안에서 일반적으로 서버에서만 돌아가는 어떤 코드든지 전부 실행 가능하다. (fs접근, db연결 등등) -> 클라이언트 측에 들어가지 않는 코드이다. 이 코드는 빌드 프로세스 중에 실행되기 때문이다.
// 이 함수 안에서는 백엔드 로직(db에서 데이터 패칭, fs데이터 패칭)같은 모든 작업 수행 가능하다.

//  getStaticProps함수 안에서 이렇게 데이터를 받아오는 작업을 완료했다면, 항상 객체를 반환 해주어야한다.
// 반드시 'props' 프로퍼티를 설정해 주어야한다. 이 프로퍼티에는 또 다른 객체를 저장하는데 이는 해당 페이지 컴포넌트 함수에서 받는 props객체가 될것이다. (여기선 HomePage컴포넌트에 매개변수로 들어가는 props)

// ** HomePage컴포넌트 코드 삽입

// api로 부터 받아온 데이터를 현재 예시 코드에선 props 프로퍼티 객체 안 'meetups'를 필드값으로 설정해준다.

// 이렇게 되면 더이상 이 컴포넌트에선 상태를 관리할 필요가 없고 useEffect훅을 사용하지 않아도 된다. -> 필요한 데이터를 이펙트 함수 호출이 아닌 props로 받았기 때문에
// 이렇게 하면 빌드 프로세스 과정쪽으로 데이터를 가져오게 된다.

// ** 페이지 소스에서 컨텐츠가 담긴 리스트 확인 사진 추가

// 이렇게 설정이 완료되면, html코드도 포함되어있고 SEO최적화도 되며 사전 렌더링 되기전에(첫번째 렌더링 사이클)에서 데이터를 받을 수 있게된다.

// SSG의 추가 정보

// 정정 사이트 생성이 잘 되었는지를 확인하기위해 npm run build를 해서 프로덕션용으로 빌드를 해보면,

// ** npm run build후 cli 화면 사진 추가

// 정적 페이지를 몇개 생성했고, 이 페이지의 경로와 범례가 나와 있다.

// 채워진 원:  SSG 사이트를 의미하고 html로 자동 생성 되었다는 뜻이다. 그리고 JSON은 SPA로 전환되면 데이터를 미리 가져오는데 사용된다.

// 비어있는 원:  정적 생성된 페이지이며 비슷하지만 유일한 차이점은 초기 props가 없다는 것이다!

// 따라서 가져온 초기 데이터가 없고 실제 루트 페이지에서만 데이터를 가져오고 있는 상황이다. -> 이 페이지 컴포넌트에서만 getStaticProps를 추가했으니

// 사실 new-meetup페이지에는 어떤 데이터도 받지 않고 있지만 받을 필요도 없더 페이지였으니 괜찮다. 사용자의 입력만 받을 양식을 렌더링해주는 역할만 하기 때문이다.
// 하지만 동적라우터로 설정한 [meetupId]페이지는 SSG설정을 해줄 필요가 있다. -> 해당하는 특정 상세 페이지의 데이터를 가져와야하기 때문이다.

// getStaticProps 사용시 체크해봐야할 중요한 점

// getStaticProps 함수를 사용할 때 생길 수 있는 문제를 생각해볼 필요가 있다. 왜냐하면 미리 데이터를 가져와서 사전에 렌더링한 상태로 업데이트를 해준다 하지만 그 데이터가 최신상태라는걸 보장 할 수는 없을것이다.
// 앞서 언급했듯, SSG설정은 빌드 프로세스에서 생성되며 배포된다 했고, 만약 DB에서 더 많은 데이터정보를 추가해도 사전에 생성된 페이지는 그 사실을 체크하지 못한다. -> 클라이언트쪽에서 데이터를 가져오지 않는다면 항상 이전의 데이터만 보게 되는것이다.

// 간단하게 생각하면 데이터가 변할 때마다 사이트를 리빌딩해서 재배포 할 수도 있다. -> 블로그나 정보만 전달되는 사이트라면 이는 괜찮은 방법일 수 있다. 하지만 데이터가 자주 바뀌는 사이트의 경우라면 getStaticProps함수에서 반환하는 객체에 프로퍼티를 하나 더 추가해 주어야한다. -> "revlidate"프로퍼티이다.

// "revlidate"
// 이 프로퍼티를 추가하면 "점진적 정적 생성"이라는 기능을 사용할 수 있다. -> 이 프로퍼티 값으로는 숫자타입이 들어가는데 요청이 들어올 때 해당 페이지를 다시 생성하기까지 대기하는 시간을 초단위로 표시하는 것이다.

// 그래서 revalidate에 값(숫자)이 설정되어 있으면 페이지는 빌드중 바로 생성되지 않는다. -> 만약 값이 10이라면, 이 페이지에 요청이 들어오면 적어도 10초마다 서버에서 페이지를 다시 생성한다는 것이다. 그렇게 되면 사전에 생성되었던 오래된 페이지를 대체하고 절대 10초보다 오래되진 않을것이다.
// revalidate의 숫자 값은 '데이터 업데이트 빈도'에 따라 결정하면 된다.(1시간마다 변하는 경우 : 3600 / 항상변해야하는 경우 : 1)

// 따라서 이 페이지는 배포 후 서버에서 때때로 다시 사전 생성 할것이기에 일부 데이터가 변경되었다고 해서 매번 리빌드하고 재배포할 필요는 없다.

// 하지만 이렇게 주기적인 업데이트만으로는 부족할 수 있다.

// 요청이 들어올 때마다 페이지를 다시 만들어야 할때가 있다. 따라서 페이지를 동적으로 프리 제너레이트(SSR) 해야한다. -> 이는 빌드프로세스가 아니고 요청이 있을때만 업데이트를 해주는 방식인것이고 이때는 'getStaticProps'의 대안인 'getServerSideProps'함수를 사용하는 것이다.

// "getServerSideProps" -> SSR

// getStaticProps함수의 차이점이라면 이 함수는 빌드 프로세스 중에는 실행되지 않는다는 점이다. 이는 배포 다음에 서버에서 실행된다
// 여기서도 객체를 리턴해주고 api에서 데이터도 패치해주는 로직을 설정한다.

// ** getServerSideProps 코드 추가

// 이 로직도 서버에서만 실행되고 프롭 객체를 리턴한다. 동일하게 컴포넌트 props로 받을 데이터를 저장하지만 revalidate는 설정 할 수 없다. -> 요청이 들어올때마다 실행되기때문에 시간 지정이 있는게 의미가 없다.

// 그리고 이 함수는 매개변수로 "context"를 받는다. 그리고 이 context로 요청객체, 응답객체에 접근할 수 있다. -> context.req / context.res

// 하지만 이 함수에서는 응답객체를 리턴하는 대신에 props프로퍼티 객체를 리턴해준다.

// 이렇게 설정해주고 페이지에 접속해서 페이지 소스를 보게 되면 리스트에 데이터가 담겨있고, 이 데이터는 페이지 요청이 들어 올때마다 프리 제너레이트되는것이다.

// 보이는것만 봤을땐 getStaticProps함수보다 getServerSideProps함수가 더 유용해 보이나, 요청이 들어올 때까지는 페이지가 만들어지기까지 기다려야한다.

// 그래서 항상 바뀌는 데이터가 없거나 요청객체에 접속할 필요가 없는 상황(인증)에서는 getStaticProps가 더 낫다. 그 이유는 html파일을 서버에서 랜더링 해주고(프리 제너레이트), 요청이 들어올 때마다 데이터를 다시 만들고 패치하는것보다 빠르기 때문이다.

// 최종적으로 현재 이 프로젝트에선 밋업데이터 리스트를 매초마다 불어오는 상황도 아니고 데이터또한 주기적으로 바뀌지 않으니 getStaticProps함수를 사용해주는게 낫다. 그렇게 되면 캐싱된 데이터를 사용할 수도 있고 여러번 서버 렌더링 요청을 하지 않아도 되기 때문이다.

// -> 상세페이지(/[meetupId]/index.js)의 데이터 패칭도 getStaticProps 함수 적용해주기
